#
# Copyright by The HDF Group.
# All rights reserved.
#
# This file is part of h5tuner. The full h5tuner copyright notice,
#  including terms governing use, modification, and redistribution, is
# contained in the file COPYING, which can be found at the root of the
# source code distribution tree.  If you do not have access to this file,
# you may request a copy from help@hdfgroup.org.
#

import subprocess
import shutil
import os
import os.path
import sys
import time
import glob
import datetime
import signal
from shutil import move
import re
import optparse

import pyevolve
from pyevolve import G1DList
from pyevolve import GSimpleGA
from pyevolve import Selectors
from pyevolve import Statistics
from pyevolve import DBAdapters
from pyevolve import GAllele
from pyevolve import Mutators
from pyevolve import Initializators
from pyevolve import Consts


from xml.dom.minidom import Document

STRING_LEN=6
NUM_ELITE=3
NUM_POP=15
NUM_GENS=40
GLOB_COUNT=0

pyevolve.logEnable()

class Alarm(Exception):
     pass

def alarm_handler(signum, frame):
     raise Alarm

#####################################################################################
#
# Tunable Parameters
#
#####################################################################################

###################
# Striping
###################

# The default value for stripe_count is 1. We are going to skip 1 and 4 because they
# are shown to be very bad. Choosing stripe_count to be -1 means stripe over all of
# available OSTs.
strp_fac_i = None

# The default value for stripe_size is 1 MB. It has to be a multiple of page size(64KB).
# A good stiripe size for seq.I/O is between 1 MB and 4 MB. The minimu is 512 KB and the
# maximum is 4 GB.
strp_unt_i = None

#######################
# Collective Buffering
#######################

# The number of aggregators
cb_nds_i = None

# Collective buffering buffer size
cb_buf_size_i = None

#################
# HDF5
#################
# HDF5 Alignment
alignment_i = None

# Data Sieving buffer size
sieve_buf_size_i = None

# Chunk size
chunk_i = None

#####################################################################
# Utility files used during the evolve iterations
#####################################################################
result_output = open('./result_output.txt', 'w')
config_feat_file = open('./config_feat.txt', 'w')
running_time_file = open('./running_time.txt', 'w')
perf_feat_filenames_file = open('./perf_feat_filenames.txt', 'w')

def eval_func(genome):
    global strp_fac_i, strp_unt_i, cb_nds_i, cb_buf_size_i, alignment_i, sieve_buf_size_i, chunk_i, run_cmd

    Logdir = './Logs/'
    HOME = os.environ['PWD']
    # set SCRATCH variable prior to execution evolve or use current directory
    if os.getenv('SCRATCH', 0):
        SCRATCH = os.environ['SCRATCH']
    else:
        # SCRATCH not defined then use PWD
        SCRATCH = os.environ['PWD']
        os.environ['SCRATCH'] = SCRATCH

    
    ####################################################################
    #
    # Create the minidom document for tunable parameters
    #
    ####################################################################
    doc = Document()

    # Create the <Parameters> base element
    params = doc.createElement("Parameters")
    doc.appendChild(params)

    high = doc.createElement("High_Level_IO_Library")
    params.appendChild(high)
    mid = doc.createElement("Middleware_Layer");
    params.appendChild(mid);
    low = doc.createElement("Parallel_File_System")
    params.appendChild(low)

    if strp_fac_i is not None:
        this_strp_fac = genome[strp_fac_i]
        if this_strp_fac.lower() != "unset":
            strp_fac_obj = doc.createElement("striping_factor")
            low.appendChild(strp_fac_obj)
            strp_fac_txt = doc.createTextNode(this_strp_fac)
            strp_fac_obj.appendChild(strp_fac_txt)
    else:
        this_strp_fac = "NA"

    if strp_unt_i is not None:
        this_strp_unt = genome[strp_unt_i]
        if this_strp_unt.lower() != "unset":
            strp_unt_obj = doc.createElement("striping_unit")
            low.appendChild(strp_unt_obj)
            strp_unt_txt = doc.createTextNode(this_strp_unt)
            strp_unt_obj.appendChild(strp_unt_txt)
    else:
        this_strp_unt = "NA"

    if cb_nds_i is not None:
        this_cb_nds = genome[cb_nds_i]
        if this_cb_nds.lower() != "unset":
            cb_n = doc.createElement("cb_nodes")
            mid.appendChild(cb_n)
            cb_n_txt = doc.createTextNode(this_cb_nds)
            cb_n.appendChild(cb_n_txt)
    else:
        this_cb_nds = "NA"

    if cb_buf_size_i is not None:
        this_cb_buf_size = genome[cb_buf_size_i]
        if this_cb_buf_size.lower() != "unset":
            cb_buf = doc.createElement("cb_buffer_size")
            mid.appendChild(cb_buf)
            cb_buf_txt = doc.createTextNode(this_cb_buf_size)
            cb_buf.appendChild(cb_buf_txt)
    else:
        this_cb_buf_size = "NA"

    if alignment_i is not None:
        this_align = genome[alignment_i]
        if this_align.lower() != "unset":
            algn = doc.createElement("alignment")
            high.appendChild(algn)
            algn_txt = doc.createTextNode(this_align)
            algn.appendChild(algn_txt)
    else:
        this_align = "NA"

    if sieve_buf_size_i is not None:
        this_siv_buf_size = genome[sieve_buf_size_i]
        if this_siv_buf_size.lower() != "unset":
            siv_buf = doc.createElement("sieve_buf_size")
            high.appendChild(siv_buf)
            siv_buf_txt = doc.createTextNode(this_siv_buf_size)
            siv_buf.appendChild(siv_buf_txt)
    else:
        this_siv_buf_size = "NA"

    if chunk_i is not None:
        this_chunk = genome[chunk_i]
        if this_chunk.lower() != "unset":
            chunk = doc.createElement("chunk")
            high.appendChild(chunk)
            chunk_txt = doc.createTextNode(this_chunk)
            chunk.appendChild(chunk_txt)
    else:
        this_chunk = "NA"

    # check to see if result's in history; if it is, use that!
    #for line in open("result_output.txt"):
    #   if str(this_strp_fac) + ", " + str(this_strp_unt) + ", " + str(this_cb_nds) + str(this_cb_buf_size) + ", " + str(this_align) + ", " + str(this_siv_buf_size) in line:
    #      return float(line.split(", ")[6])

    str_param = this_strp_fac + ', ' + this_strp_unt + ', ' + this_cb_nds + ', ' + this_cb_buf_size + ', ' + this_align + ', ' + this_siv_buf_size + ', ' + this_chunk

    print "Evaluate Parameters config (%s): " % (str_param)
    #sys.stdout.flush()

    home_dir = os.environ['PWD'];
    file_path = home_dir + 'config.xml'
    config_file = open(file_path, 'w');
    config_file.write(doc.toprettyxml(indent="  "))
    config_file.close()
    os.environ['H5TUNER_CONFIG_FILE'] = file_path

    ####################################################################
    #
    #  Application/Job Execution
    #
    ####################################################################

    print 'Starting Application Execution'
    #sys.stdout.flush()

    todays_date = datetime.datetime.now()
    print todays_date

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(59*60)  # 59 minutes

    #################################
    # SIZE OF THE OUTPUT FILE OF
    #################################
    VPIC_128 = 32000000
    VORPAL_128 = 34000000
    GCRM_128 = 30000000
    VPIC_512 = 120000000
    VORPAL_512 = 120000000
    GCRM_512 = 120000000
    VPIC_4096 = 1000000000

    try:
        valid = 0;
        start = 0.0;
        elapsed = 0.0;
        for i in range(5):
            start = time.time()


            q = subprocess.Popen(run_cmd, stdout=subprocess.PIPE, shell=True)
            out, err = q.communicate()
            print out

            if q.returncode == 0:
                elapsed = (time.time() - start)
                print 'elapsed time; ', elapsed
            else:
                elapsed = float("inf")
                print 'failure encountered!'

    except Alarm:
        print 'Taking too long, returning\n'
        return float("inf");

    ################################################################
    # Evolution settings results update
    ################################################################

    global NUM_POP, NUM_ELITE, GLOB_COUNT
    this_gen = GLOB_COUNT / NUM_POP
    GLOB_COUNT = GLOB_COUNT + 1
    print 'Glog_count ', GLOB_COUNT
    print 'this_gen', this_gen
    print 'num pop',NUM_POP,'num elite',NUM_ELITE

    str_result = str(this_gen) + ': ' + str_param + ': ' + str(elapsed)

    config_feat_file.write(str_param)
    config_feat_file.write('\n')

    result_output.write(str_result)
    result_output.write('\n')
    running_time_file.write('[' + str(todays_date) + '] ' + str_result + '=' + str(valid) + '\n')

    sys.stdout.flush()
    result_output.flush()
    config_feat_file.flush()
    running_time_file.flush()
    perf_feat_filenames_file.flush()

    return float(elapsed)

#def ConvergenceCriteria(ga_engine):
#    best = ga_engine.bestIndividual()
    # Best Score of 128 cores is about 50 seconds
#    return best.score <= 40
    # Best Score of 4096 cores is about 600 seconds
    #return best.score <= 600


def run_main():
    print "Starting main()!"
    #sys.stdout.flush()
    global NUM_GENS, NUM_POP, NUM_ELITE, GLOB_COUNT, strp_fac_i, strp_unt_i, cb_nds_i, cb_buf_size_i, alignment_i, sieve_buf_size_i, chunk_i, run_cmd

    # Set up parser
    parser = optparse.OptionParser()

    # Add striping factor option
    parser.add_option("--striping_factor", action="store", dest="strp_fac_str")

    # Add striping unit option
    parser.add_option("--striping_unit", action="store", dest="strp_unt_str")

    # Add collective buffering nodes option
    parser.add_option("--cb_nodes", action="store", dest="cb_nds_str")

    # Add collective buffering buffer size option
    parser.add_option("--cb_buffer_size", action="store", dest="cb_buf_size_str")

    # Add alignment option
    parser.add_option("--alignment", action="store", dest="alignment_str")

    # Add sieve buffer size option
    parser.add_option("--sieve_buf_size", action="store", dest="sieve_buf_size_str")

    # Add chunk size option
    parser.add_option("--chunk", action="store", dest="chunk_str")

    # Parse options
    opt, run_cmd = parser.parse_args()

    # Keep track of index in genome
    genome_i = 0

    # Start building genome
    setOfAlleles = GAllele.GAlleles()

    # Handle striping factor
    if opt.strp_fac_str is not None:
        # Build list for genome
        strp_fac = opt.strp_fac_str.replace(" ", "").split(",")

        # Add to genome
        gal = GAllele.GAlleleList(strp_fac)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        strp_fac_i = genome_i
        genome_i += 1

    # Handle striping unit
    if opt.strp_unt_str is not None:
        # Build list for genome
        strp_unt = opt.strp_unt_str.replace(" ", "").split(",")

        # Add to genome
        gal = GAllele.GAlleleList(strp_unt)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        strp_unt_i = genome_i
        genome_i += 1

    # Handle collective buffering nodes
    if opt.cb_nds_str is not None:
        # Build list for genome
        cb_nds = opt.cb_nds_str.replace(" ", "").split(",")

        # Add to genome
        gal = GAllele.GAlleleList(cb_nds)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        cb_nds_i = genome_i
        genome_i += 1

    # Handle collective buffering buffer size
    if opt.cb_buf_size_str is not None:
        # Build list for genome
        cb_buf_size = opt.cb_buf_size_str.replace(" ", "").split(",")

        # Add to genome
        gal = GAllele.GAlleleList(cb_buf_size)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        cb_buf_size_i = genome_i
        genome_i += 1

    # Handle alignment
    if opt.alignment_str is not None:
        # Build list for genome
        alignment_size = opt.alignment_str.replace(" ", "").split(";")

        # Add to genome
        gal = GAllele.GAlleleList(alignment_size)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        alignment_i = genome_i
        genome_i += 1

    # Handle sieve buffer size
    if opt.sieve_buf_size_str is not None:
        # Build list for genome
        sieve_buf_size = opt.sieve_buf_size_str.replace(" ", "").split(",")

        # Add to genome
        gal = GAllele.GAlleleList(sieve_buf_size)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        sieve_buf_size_i = genome_i
        genome_i += 1

    # Handle chunk size
    if opt.chunk_str is not None:
        # Build list for genome
        chunk = opt.chunk_str.replace(" ", "").split(";")

        # Add to genome
        gal = GAllele.GAlleleList(chunk)
        setOfAlleles.add(gal)

        # Keep track of index in genome
        chunk_i = genome_i
        genome_i += 1

    genome = G1DList.G1DList(genome_i)
    genome.setParams(allele=setOfAlleles)

    genome.evaluator.set(eval_func)
    genome.mutator.set(Mutators.G1DListMutatorAllele)
    genome.initializator.set(Initializators.G1DListInitializatorAllele)

    ga = GSimpleGA.GSimpleGA(genome)
    ga.selector.set(Selectors.GRouletteWheel)
    ga.setMutationRate(0.15);
    ga.setGenerations(NUM_GENS)
    #ga.terminationCriteria.set(ConvergenceCriteria)
    ga.setPopulationSize(NUM_POP)
    ga.setMinimax(Consts.minimaxType["minimize"])
    ga.setElitism(True)
    ga.setElitismReplacement(NUM_ELITE)
    print 'ga.evolve'
    ga.evolve(freq_stats=1)
    print 'closing result'
    result_output.close()

    print 'Evolution Parameters:'
    param_str = "["
    if strp_fac_i is not None:
        param_str += "striping_factor"
    if strp_unt_i is not None:
        if len(param_str) > 1:
            param_str += ", "
        param_str += "striping_unit"
    if cb_nds_i is not None:
        if len(param_str) > 1:
            param_str += ", "
        param_str += "cb_nodes"
    if cb_buf_size_i is not None:
        if len(param_str) > 1:
            param_str += ", "
        param_str += "cb_buffer_size"
    if alignment_i is not None:
        if len(param_str) > 1:
            param_str += ", "
        param_str += "alignment"
    if sieve_buf_size_i is not None:
        if len(param_str) > 1:
            param_str += ", "
        param_str += "sieve_buf_size"
    if chunk_i is not None:
        if len(param_str) > 1:
            param_str += ", "
        param_str += "chunk"
    param_str += "]"
    print param_str

    print 'Best Solution:'
    print ga.bestIndividual()

if __name__ == "__main__":
    run_main();
